#+TITLE: Scavenger Hunt

#+STARTUP: inlineimages
#+PROPERTY: header-args:haskell :results replace output
#+PROPERTY: header-args:haskell+ :noweb yes
#+PROPERTY: header-args:haskell+ :wrap EXAMPLE

* A new algebra

We are going to design another algebra, a more "real-world" case study: a
backend service for a "scavenger hunt" platform.

Our service will let players to:

- Run around the city
- Following clues
- Solving puzzles
- Exploring new places
- Doing challenges

Mechanics of the MVP:

- Collect periodic location data of the players
- Players can send geotagged photos
- Locations and geotagged photos will be used to "prove" the progression of the
  player
- For every challege the player completes a "reward" will be given: can be a
  point on the leaderboard or something else
- After a challege is completed, the player is free to tackle another challenge
- Challeges must be defined in a way so that everyone in the company can
  contribute to create them

*Exercise*: Attempt a quick design of this system before continuing. Sketch the
core data types and functions necessary for a scavenger hunt system like
described above. How would you encode a challenge like “take a selfie at the
library, and receive one point afterward.”

#+BEGIN_SRC haskell :eval never
data Player

data Challege = Challenge(Action, Rewad)

data Action = SelfieAt(Place) -- | ... other actions

data Place = Place(Coordinates)

data Position = Position(Player, Place)

data Reward = Earn(Points) -- | ... other rewards

data Points = Point(Int)

placeKnownAs :: String -> Place
placeKnownAs = undefined

reportPosition :: Player -> Coordinates -> Position
reportPosition = undefined

reportAction :: Challenge -> Player -> Action -> Maybe Reward
reportAction = undefined

challenge = Challenge(SelfieAt(placeKnownAs("library")), Earn(Point(1)))
#+END_SRC

*Exercise*: Try to represent a challenge that requires players to go to the
beach and to the library — but in either order — and then receive a reward. Can
your initial design represent this problem? If not, modify the core data types
to support this functionality.

#+BEGIN_SRC haskell
data Action = SelfieAt(Place) | Both(Action, Action)

challenge = Challenge(
  Both(
      SelfieAt(placeKnownAs("library")),
      SelfieAt(placeKnownAs("beach"))),
  Earn(Point(1))
)
#+END_SRC

#+BEGIN_QUOTE
A great place to begin any algebra is by determining some of its observations,
that is, the answer to “what is the purpose of this thing we’re building?”
#+END_QUOTE

#+BEGIN_SRC haskell :eval never
data Challenge
data Input
data Reward

getRewards :: Challenge -> [Input] -> [Reward]
#+END_SRC

Algebra-Driven Design forces us to be /denotational/ therefore we cannot use
mutation of variables therefore we must receive the whole player history to
determine the rewards.

#+BEGIN_SRC haskell :eval never
data Clue
data Point
data Distance

pointOfInterest :: Clue
                -> Point
                -> Distance
                -> Reward
                -> Challege

photo :: Point -> Photo -> Input
within :: Point -> Point -> Distance -> Bool
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: point of interest
-- if the challenge is a pointOfInterest, and the user sends us a photo
-- taken in the proximity circle, then they should receive the associated reward.

∀ (c :: Clue) (poi :: Point) (d :: Distance) (r :: Reward) (p :: Point) (pic :: Photo) (is: [Input]).
  within poi p d =>
    getRewards (pointOfInterest c poi d r)
               (photo p pic : is)
               = [r]
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Law: outside point of interest
-- states that the getRewards of a pointOfInterest ignores any photo inputs that
-- are not within the location tolerance.

∀ (c :: Clue) (poi :: Point) (d :: Distance) (r :: Reward) (p :: Point) (pic :: Photo) (is: [Input]).
  not (within poi p d) =>
    getRewards (pointOfInterest c poi d r)
               (photo p pic : is)
               =
    getRewards (pointOfInterest c poi d r)
               is
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Law: unmatching point of interest
-- ignore any input which is not a photo

-- given the trivial observation `isPhoto :: Input -> Bool`

∀ (c :: Clue) (poi :: Point) (d :: Distance) (r :: Reward) (i :: Input) (is: [Input]).
  not (isPhoto i) =>
    getRewards (pointOfInterest c poi d r)
               (i : is)
               =
    getRewards (pointOfInterest c poi d r)
               is
#+END_EXAMPLE

This time the laws seems more convoluted, is it because the domain is more
complex or because we got the wrong algebra?

#+BEGIN_QUOTE
Involved equations are a classic symptom of designing the wrong algebra.
#+END_QUOTE

Note that the ~pointOfInterest~ constructor takes 4 parameters and does 3
orthogonal things:
- Informing the user (the ~Clue~)
- Describing an area (the ~Point~ and ~Distance~)
- Giving a ~Reward~

Looking at the laws:
- All three laws don't care about the ~Clue~
- Two of them don't care about the ~Reward~ (NDG: mmm, but they always compare
  the result of ~getRewards~ which is a list of ~Reward~ 🤔)

Conclusion: ~pointOfInterest~ is not about ~Clue~ and ~Reward~

#+BEGIN_SRC haskell :eval never
clue :: Clue -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: getRewards/clue
-- clues do not affect rewards

∀ (cl :: Clue) (ch :: Challenge).
  getRewards (clue cl ch) = getRewards ch

-- NDG: are we missing the inputs? Should have been
∀ (cl :: Clue) (ch :: Challenge) (is :: [Input]).
  getRewards (clue cl ch) is = getRewards ch is

-- NDG: it's basically the same thing considering an eta reduction on `is`,
-- aka: the first law is comparing two functions both awaiting `is`, they
-- will be equal `f1 = f2 iff ∀ (is : [Input]). f1 is = f2 is`
#+END_EXAMPLE

By intuition we make a ~reward~ constructor a terminal able to create a
~Challenge~ from nothing.

#+BEGIN_SRC haskell :eval never
reward :: Reward -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law :: getRewards/reward
-- a `reward` challenge doesn't have any requirements, for every input we give the reward

∀ (r :: Reward) (is :: [Input]).
  getReward (reward r) is = [r]
#+END_EXAMPLE

*Exercise*: Reduce ~getRewards (clue c (reward r)) i~ to its simplest form via
algebraic manipulation.

#+BEGIN_EXAMPLE
getRewards (clue c (reward r)) i    -- using: getRewards (clue cl ch) = getRewards ch
getRewards (reward r) i             -- using: getReward (reward r) i = [r]
[r]
#+END_EXAMPLE

We can pull the remaining two parameters (~Point~ and ~Distance~) in their own constructor

#+BEGIN_SRC haskell :eval never
photoWithin :: Point
            -> Distance
            -> Challenge
            -> Challenge
#+END_SRC

The idea is that ~photoWithin~ will wait until a photo has been taken within the
tollerance and before switching to its ~reward~ challege (which will give
immediately back the reward)

#+BEGIN_EXAMPLE
-- Law: getReward/photoWithin

∀ (poi :: Point) (p :: Point) (pic :: Photo) (d :: Distance) (c :: Challege) (is :: [Input]).
  within poi p d =>
    getRewards (photoWithin poi d c) (photo p pic : is) = getRewards c is

-- NDC: I'm not convinced, this means that you need to build build "carefully" the challenge, you can miss the reward

-- We still need to express the laws describing the behaviour of not getting a reward if
-- the selfie is not in range and if the input is not a selfie

-- Law: getReward/photoWithin outside range
∀ (poi :: Point) (p :: Point) (pic :: Photo) (d :: Distance) (c :: Challege) (is :: [Input]).
  not (within poi p d) =>
    getRewards (photoWithin poi d c) (photo p pic : is) = getRewards (photoWithin poi d c) is

-- Law: getReward/photoWithin unmatching photoWithin
∀ (poi :: Point) (d :: Distance) (c :: Challege) (i :: Input) (is :: [Input]).
  not (isPhoto) =>
    getRewards (photoWithin poi d c) (i : is) = getRewards (photoWithin poi d c) is

-- Law: pointOfInterest
-- pointOfInterest now can be espressed by composition of simpler constructors
∀ (c :: Clue) (p :: Point) (d :: Distance) (r :: Reward).
  pointOfInterest c p d r = clue c (photoWithin p d (reward r))
#+END_EXAMPLE

We need to be able to track if the photo was taken at a certain altitude (ex.
for a building rooftop)

#+BEGIN_SRC haskell :eval never
data Altitude

photoAbove :: Altitude
           -> Challenge
           -> Challenge

-- to replace `within` predicate
aboveAltitude :: Point -> Altitude -> Bool
#+END_SRC

NOTE: in our laws we used directly ~within~ so the laws are not generic on the
predicate or on the kind of challenge

* Input Filters

There are similarities between ~photoWithin~ and ~photoAbove~, they both scan
through an ~Input~ list until they are satisfied. Can we parametrize this
behaviour?

#+BEGIN_SRC haskell :eval never
data InputFilter

matches :: InputFilter -> Input -> Bool

photoWithin :: Point -> Distance -> InputFilter
photoAbove :: Altitude -> InputFilter
#+END_SRC

*Exercise:* Give semantics in terms of matches for both ~photoWithin~ and
~photoAbove~.

#+BEGIN_EXAMPLE
-- Law: matches/photoWithin
∀ (p1 :: Point) (p2 :: Point) (d :: Distance) (pic :: Photo).
  matches (photoWithin p1 d) (photo p2 pic) = within p1 p2 d

-- Law: matches/photoAbove
∀ (p :: Point) (h :: Altitude) (pic :: Photo).
  matches (photoAbove h) (photo p pic) = aboveAltitude p h
#+END_EXAMPLE

We can then create a constructor for ~Challege~ which will apply the filter.

#+BEGIN_SRC haskell :eval never
gate :: InputFilter -> Challenge -> Challenge
#+END_SRC

With the following semantics

#+BEGIN_EXAMPLE
-- Law: getRewards/gate
∀ (c :: Challenge) (f :: InputFilter) (i :: Input) (is :: [Input]).
  matches f i =>
    getRewards (gate f c) (i : is) = getRewards c is

-- Law: getRewards/gate unmatched
∀ (c :: Challenge) (f :: InputFilter) (i :: Input) (is :: [Input]).
  not (matches f i) =>
    getRewards (gate f c) (i : is) = getRewards (gate f c) is

-- Law: getRewards/gate empty
∀ (c :: Challenge) (f :: InputFilter).
  getRewards (gate f c) [] = []
#+END_EXAMPLE

Finally we can now express ~pointOfInterest~ in terms of gate

#+BEGIN_EXAMPLE
-- Law: pointOfInterest
∀ (c :: Clue) (p :: Point) (d :: Distance) (r :: Reward).
  pointOfInterest c p d r = clue c (gate (photoWithin p d) (reward r))
#+END_EXAMPLE

Can we combine more ~InputFilter~?

#+BEGIN_SRC haskell
always :: InputFilter
never :: InputFilter

andF :: InputFilter -> InputFilter -> InputFilter
orF :: InputFilter -> InputFilter -> InputFilter
notF :: InputFilter -> InputFilter
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: matches/always
∀ (i :: Input).
  matches always i = True

-- Law: matches/never
∀ (i :: Input).
  matches never i = False

-- Law: matches/andF
∀ (i :: Input) (f1 :: InputFilter) (f2 :: InputFilter).
  matches (andF f1 ff2) i = matches f1 i && matches f2 i

-- Law: matches/orF
∀ (i :: Input) (f1 :: InputFilter) (f2 :: InputFilter).
  matches (andF f1 ff2) i = matches f1 i || matches f2 i

-- Law: matches/notF
∀ (i :: Input) (f :: InputFilter).
  matches (notF f) i = not (matches f i)
#+END_EXAMPLE

* Simultaneous Challenges

*Exercise:* Consider the term ~gate (photoWithin p1 d1) (gate (photoWithin p2
d2) (reward r))~. What is your intuitive understanding of this expression? Do
our stated semantics agree with you? Hint: try evaluating ~getRewards~ of the
above, using two different photo inputs.

#+BEGIN_EXAMPLE
-- The player will get a reward if the input sequence contains first a photo matching the
-- filter `(photoWithin p1 d1)` and the a photo matchin the filter `(photoWithin p2 d2)`

getRewards (gate (photoWithin p1 d1) (gate (photoWithin p2 d2) (reward r))) ((photo p3 pic1) : (photo p4 pic2) : [])
-- if (matches (photoWithin p1 d1) (photo p3 pic1))
getRewards (gate (photoWithin p2 d2) (reward r)) ((photo p4 pic2) : [])
-- if (matches (photoWithin p2 d2) (photo p4 pic2))
getRewards (reward r) []
-- using `getReward (reward r) is = [r]`
[r]
#+END_EXAMPLE

We can create a new ~InputFilter~ to check the passive location data of the player

#+BEGIN_SRC haskell :eval never
logWithin :: Point -> Distance -> InputFilter
#+END_SRC

*Exercise:* Use ~locWithin~ to encode a challenge that requires our player to
walk around the block twice, clockwise, as in figure 4.9. Assume you have p1,
p2, p3 :: Point and d1, d2, d3 :: Distance corresponding to each corner’s
locations and tolerances.

#+BEGIN_SRC haskell :eval never
aroundTheBlock :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlock [] c = c
aroundTheBlock ((p, d):t) c = gate (logWith p d) (aroundTheBlock t c)

aroundTheBlockTwice :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlockTwice ps c = aroundTheBlock ps (aroundTheBlock ps c)

twice :: (Challenge -> Challenge) -> Challenge -> Challenge
twice build c = build (build c)

aroundTheBlockTwice' :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlockTwice' ps c = twice (aroundTheBlock ps) c

repeatN :: Int -> (Challenge -> Challenge) -> Challenge -> Challenge
repeatN 0 _ c = c
repeatN n build c = build $ repeatN (n - 1) build c

aroundTheBlockTwice'' :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlockTwice'' ps c = repeatN 2 (aroundTheBlock ps) c
#+END_SRC

Can we encode a challenge in which players can visit several points of interest
in ~any~ order?

We need a new constructor

#+BEGIN_SRC haskell :eval never
both :: Challenge -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: both/commutative
∀ (c1 :: Challenge) (c2 :: Challenge).
  both c1 c2 = both c2 c1

-- Law: both/associative
∀ (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  both (both c1 c2) c3 = both c1 (both c2 c3)

-- Law: both/idempotent
∀ (c :: Challenge).
  both c c = c

-- Law
∀ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  getRewards (both c1 c2) is = (getRewards c1 is) ++ (getRewards c2 is)
#+END_EXAMPLE

*Exercise:* Prove that ~both (both c1 c2) (both c3 c4) = both c1 (both c2 (both
c3 c4))~. How might an implementation use this fact?

#+BEGIN_EXAMPLE
both (both c1 c2) (both c3 c4) = both c1 (both c2 (both c3 c4))

both (both c1 c2) (both c3 c4) -- from associativity
both c1 (both c2 (both c3 c4))

-- Can be used to balance the tree, to reduce the depth of the tree, to improve performance
#+END_EXAMPLE

With ~both~ the player gets both the rewards of the composing challenges, but
what about we want to give the reward only when all the challenges are complete?

We miss the capability to create a ~Challenge~ that has no reward at the end

#+BEGIN_SRC haskell :eval never
empty :: Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: getRewards/empty
∀ (is :: [Input]).
  getRewards empty is = []

∀ (c :: Challenge).
  both empty c = c = both c empty
#+END_EXAMPLE

* Challenge Completion

Right now we don't have a way to wait for a challenge completion to go to the
next challenge, for example in case of ~both c1 c2~ the player will get both the
rewards for ~c1~ and ~c2~, we cannot say "if the player completes both
challenges then this is the reward"

We need a new combinator for that, a combinator capable of /sequencing/
challenges

#+BEGIN_SRC haskell :eval never
andThen :: Challenge -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: andThen/gate
∀ (f :: InputFilter) (c1 :: Challenge) (c2 :: Challenge).
  andThen (gate f c1) c2 = gate f (andThen c1 c2)

-- Law: andThen:associative
∀ (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  andThen (andThen c1 c2) c3 = andThen c1 (andThen c2 c3)

-- Law: andThen:identity
∀ (c :: Challenge).
  andThen c empty = andThen empty c = c
#+END_EXAMPLE

We lack a strong definition of challenge /completion/

#+BEGIN_QUOTE
Semantics must always be relative to an observation
#+END_QUOTE

Our only observation for challenges so far is ~getRewards~ which is not suited
to define challenges completion, we need another observation.

Let's try using the following (spoiler: it's not compositional enough because it
doesn't tell us how much input is needed for a challenge to complete)

#+BEGIN_SRC haskell :eval never
completes :: Challenge -> [Input] -> Bool
#+END_SRC

*Exercise:* Give semantics for ~andThen~ in terms of ~completes~ as defined
 above. Show that this semantic necessarily contradict "andThen/gate"

#+BEGIN_EXAMPLE
-- Law: completes/andThen
∀ (c1 :: Challenge) (c2 :: Challege) (is1 :: [Input]) (is2 :: [Input]).
  completes c1 is1 && completes c2 is2 =>
    completes (andThen c1 c2) (is1 ++ is2)

-- Law: completes/gate
∀ (f :: InputFilter) (c :: Challenge) (i: Input) (is: [Input]).
  matches f i =>
    completes (gate f c) (i :: is) = completes c is

∀ (f :: InputFilter) (c :: Challenge) (i: Input) (is: [Input]).
  not (matches f i) =>
    completes (gate f c) (i :: is) = completes (gate f c) is

-- Law: completes/end
∀ (c :: Challenge).
  completes c [] = false

-- Law: completes/reward
∀ (is :: [Input]) (reward R).
  completes (reward R) is = true

-- Law: completes/empty
∀ (is :: [Input]).
  completes empty is = true


-- REDO, wrong interpretation of complete
--
--
-- Given the following law
∀ (f :: InputFilter) (c1 :: Challenge) (c2 :: Challenge).
  andThen (gate f c1) c2 = gate f (andThen c1 c2)

∀ (c1 :: Challenge) (c2 :: Challege) (i :: Input) (is1 :: [Input]) (is2 :: [Input]).
  completes (gate f c1) (i : is1) && completes c2 is2 =>
    completes (andThen (gate f c1) c2) ((i : is1) ++ is2)

-- the following expression
completes (andThen (gate f c1) c2) ((i : is1) ++ is2)
-- should be equal to
completes (gate f (andThen c1 c2)) ((i : is1) ++ is2)

-- but the second form will consume all the input to check if `gate` is satisfied
#+END_EXAMPLE

More composable version of ~completes~ will preserve the information on the
amount of input necessary to complete a challege and leave the rest

#+BEGIN_SRC haskell
completes :: Challenge -> [Input] -> Maybe [Input]
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: completes/empty
-- An empty challenge is always completed
∀ (is :: [Input]).
  completes empty is = Just is

-- Law: completes/reward
-- A reward challenge is always completed
∀ (r :: Reward) (is :: [Input]).
  completes (reward r) is = Just is

-- Law: completes/both
-- where `shorterOf :: [a] -> [a] -> [a]` will return the shorter not remaining input
∀ (c1 :: Challege) (c2 :: Challenge) (is :: [Input]).
  completes (both c1 c2) is = shorterOf <$> completes c1 is <*> completes c2 is
#+END_EXAMPLE

*Exercise:* Give a law for the behaviour of ~shorterOf~

#+BEGIN_EXAMPLE
-- Law: shorter:behaviour
∀ (as :: [a]) (a :: a).
  shorterOf (a : as) as = as

-- Law: shorter:commutative
∀ (as1 :: [a]) (as2 :: [a]).
  shorterOf as1 as2 = shorterOf as2 as1

-- Law: shorter:base
∀ (as :: [a]).
  shorterOf as [] = []

-- Law: shorter:associative
∀ (as1 :: [a]) (as2 :: [a]) (as3 :: [a]).
  shorterOf as1 (shorterOf as2 as3) = shorterOf (shorterOf as1 as2) as3

-- Law: shorter:identity
∀ (as :: [a]).
  shorterOf as as = as
#+END_EXAMPLE

*Exercise:* Does shorterOf form a monoid? If so, give it. If not, show which
laws it doesn’t satisfy.

No, the /identity element/ doesn't exists (should have been the infinitely long
list), but it's associative, therefore it's a semigroup

Going further with the laws regarding the ~completes~ observation

#+BEGIN_EXAMPLE
-- Law: completes/clue
∀ (k :: Clue) (c :: Challege) (is :: [Input]).
  completes (clue k c) is = completes c is

-- Law: completes/gate
∀ (f :: InputFilter) (c :: Challege) (i :: Input) (is :: [Input]).
  matches f i =>
    completes (gate f c) (i : is) = completes c is

-- Law: completes/gate unmatched
∀ (f :: InputFilter) (c :: Challege) (i :: Input) (is :: [Input]).
  not (matches f i) =>
    completes (gate f c) (i : is) = completes (gate f c) is

-- Law: completes/gate empty
∀ (f :: InputFilter) (c :: Challege).
  completes (gate f c) [] = Nothing
#+END_EXAMPLE

Now we can properly specify the semantics of ~andThen~ under ~completes~ because
we can use the rest of the input of the first challenge to run the second
challenge

#+BEGIN_EXAMPLE
-- Law: completes/andThen
∀ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  completes (andThen c1 c2) is =
    completes c1 is >>= completes c2

-- (>>=) :: Monad m => m a -> (a -> m b) -> m b
-- Maybe [Input] >>= ([Input] -> Maybe [Input])

-- flatMap[M[_], A, B](ma : M[A])(f: A => M[B]): M[B]
-- flatMap(ma : Option[Input[]])(f: Input[] => Option[Input[]]): Option[Input[]]
#+END_EXAMPLE

#+BEGIN_QUOTE
Using ~>>=~ is highly appropriate, monadic binds are used to encode strict
sequencing of evaluation in lazy languages. Transforming from constructors to a
well-understood operation is a recurring theme in Algebra-Driven Design, and
this is the proof that our algebra behaves liek we say it should.
#+END_QUOTE

Last thing is to give semantics of ~andThen~ under ~getRewards~

#+BEGIN_EXAMPLE
-- Law: getRewards/andThen
-- This should be good for both cases
∀ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  getRewards (andThen c1 c2) is =
    (getRewards c1 is) <> (getRewards c2 <$> completes c1 is)

-- More explicit
-- Law: getRewards/andThen
∀ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]) (is' :: [Input]).
  completes c1 is == Just is' =>
    getRewards (andThen c1 c2) is =
      getRewards c1 is <> getRewards c2 is'

-- Law: getRewards/andThen incomplete
∀ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  completes c1 is == Nothing =>
    getRewards (andThen c1 c2) is =
      getRewards c1 is
      -- That is because c1 never completes, therefore the
      -- remaining input will be empty, therefore the c2
      -- challenge will result in empy rewards, therefore
      -- can be elimnated
#+END_EXAMPLE

* Simplification

Give distributive laws when possible

#+BEGIN_EXAMPLE
-- Law: both/andThen/reward
∀ (r :: Reward) (c1 :: Challenge) (c2 :: Challenge).
  both (andThen (reward r) c1) c2 =
    andThen (reward r) (both c1 c2)

-- Law: both/andThen/reward
∀ (r :: Reward) (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  completes c1 is == Just is' =>
    both (andThen c1 c2) c3 is =
      andThen c1 (both c2 c3) is
#+END_EXAMPLE

Our algebra is *inconsistent!!!*, it shows a non-confluence, aka a term can be
reduced in two different lawful ways to two diffent terms.

#+BEGIN_QUOTE
In computer science and mathematics, /confluence/ is a property of rewriting
systems, describing which terms in such a system can be rewritten in more than
one way, to yield the /same result/.
#+END_QUOTE

#+BEGIN_EXAMPLE
both (reward r1) (reward r2)                   -- using: andThen c empty = andThen empty c = c
both (andThen (reward r1) empty) (reward r2)   -- using: both (andThen (reward r) c1) c2 = andThen (reward r) (both c1 c2)
andThen (reward r1) (both empty (reward r2))   -- using: both (empty c) = c
andThen (reward r1) (reward r2)

both (reward r1) (reward r2)                   -- using: both c1 c2 = both c2 c1
both (reward r2) (reward r1)                   -- using: andThen c empty = andThen empty c = c
both (andThen (reward r2) empty) (reward r1)   -- using: both (andThen (reward r) c1) c2 = andThen (reward r) (both c1 c2)
andThen (reward r2) (both empty (reward r1))   -- using: both (empty c) = c
andThen (reward r2) (reward r1)

-- Therefore
andThen (reward r2) (reward r1) == andThen (reward r1) (reward r2)

-- Is this true? For a human yes 😃 for a formal system no!
-- That is because when observed through `gerRewards` we get that

getRewards (andThen (reward r2) (reward r1)) = [r1, r2]
getRewards (andThen (reward r1) (reward r2)) = [r2, r1]

-- But

[r1, r2] !== [r2, r1]
#+END_EXAMPLE

The problem lies in the relationship between ~both:commutative~ and
~both:idempotent~ and the rewarding system represented as a list of rewards, and
a list is neither commutaive nor idempotent

How to fix it?
- Abandon the ~both:commutative~ and ~both:idempotent~ laws
- Change the result type of ~getRewards~
- Try to force commutativity and idempotence in lists with ad-hoc laws

NDG: I don't understand the following quote

#+BEGIN_QUOTE
Invariants are a feature of the implementation, not of the design.
#+END_QUOTE

Changing the result type of ~getRewards~ to be both commutative and idempotent
seems to be the way, we can use a [[https://en.wikipedia.org/wiki/Multiset][Multiset]]

NDG: So the algebra was inconsistent, but we fixed it by changing an observation
🤔

#+BEGIN_SRC haskell
getRewards :: Challenge -> [Input] -> Multiset Reward
#+END_SRC

* A Unified Observation
Looking at what we have right now:
- Feels like it's still complicated to evaluate challenges
- We can operate algebraic reductions without the need of inputs
- Looking at our current observations (~getRewards~ and ~completes~) all of them
  only requires the first input in the sequence of inputs, every time we need to
  duplicate the "traversal" of the inputs, aka is not required for inputs to be
  a list

We can propose another observation meant to replace both the previous
observations. NOTE: it works only considering ~empty~ as the only "complete"
challenge (aka when to stop the "steps")

#+BEGIN_SRC haskell :eval never
step :: Maybe Input -> Challenge -> (Multiset Reward, Challenge)
#+END_SRC

NDG: probably we can use ~(Maybe Reward, Maybe Challenge)~ instead of having an
~empty~ challenge, but I know why he did that, because otherwise the laws below
would be more convoluted (~(a, Maybe)~ is an ~Applicative Applicative~)

#+BEGIN_EXAMPLE
-- Law: step/both
∀ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step i (both c1 c2) = both <$> (step i c1) <*> (step i c2)

-- How it works?
-- (step i c1) :: (Multiset Reward, Challenge)
-- (a,) has an instance of `Applicative` only if `Monoid a`
-- both :: Challenge -> Challenge -> Challenge
-- both <$> (a, Challenge) :: (a, Challenge -> Challenge)
-- both <$> (a, Challenge) <*> (a, Challenge) :: (a, Challenge)
-- where the `a` in the first element of the tuple gets "merged" using its monoid instance

-- in the end the result will be `(rc1 <> rc2, both cc1 cc2)`
-- where `rcN` are the rewards for `(step i cN)`
-- and `ccN` are the challenges for `(step i cN)`

-- Law: step/empty
∀ (i :: Maybe Input).
  step i empty = pure empty -- meaning `(mempty, empty)` where `mempty :: Monoid a => a`

-- Law: step/reward
∀ (i :: Maybe Input) (r :: Reward).
  step i (reward r) = (singleton r, empty) -- where `singleton :: a -> Multiset a`

-- Law: step/gate
∀ (i :: Input) (f :: InputFilter) (c :: Challenge).
  matches f i =>
    step (Just i) (gate f c) = step Nothing c

-- NDG: I would have said `= pure c` which is the equivalent given the law below "step/gate nothing"

-- Law: step/gate unmatched
∀ (i :: Input) (f :: InputFilter) (c :: Challenge).
  not (matches f i) =>
    step (Just i) (gate f c) = pure (gate f c)

-- Law: step/gate nothing
∀ (f :: InputFilter) (c :: Challenge).
  step Nothing (gate f c) = pure (gate f c)

-- Law: step/andThen complete
∀ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge) (r :: Reward).
  step i c1 == (r, empty) =>
    step i (andThen c1 c2) = join (r, step Nothing c2)

-- join :: Monad a => Monad (Monad a) = Monad a
-- here join :: (,) (,) a -> (,) a
-- here (r, step Nothing c2) -> (r, (r1, c3)) -> (r <> r1, c3)

-- Why `step Nothing c2` ???
-- first we should note that: `step Nothing c2 = pure c2`
-- then, with this we are not saying that we are running the second
-- challenge without input, but that we are returning the second
-- challenge to whoever is consuming the inputs using `step`

-- The following is the general version

-- Law: step/andThen incomplete
∀ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step i c1 == (_, c1') && not (isEmpty c1') =>
    step i (andThen c1 c2) = andThen <$> step i c1 <*> pure c2
#+END_EXAMPLE

This is how we will "consume" the inputs

#+BEGIN_EXAMPLE
∀ (c :: Challenge).
  runChallenge c = foldM step c . (Nothing :) . fmap Just

-- `fmap Just` turns `[Input]` in `[Maybe Input]`
-- `(Nothing : )` prepends a Nothing to the list of input `Nothing : [Maybe Input]` to be able
-- to run the challenge at least once even when there's no input available
-- At the end we fold the `[Maybe Input]` starting with `c` using `step`

-- foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- We can do that because `Monoid a => Monad ((,) a)` aka there's an instance of `Monad`
-- for two elements tuples where the first element has an instance of `Monoid`, and
-- `Reward` has an instance of `Monoid`
#+END_EXAMPLE

If we worry that we lost something with the unified observation, we can try to
implement the original observations using the unified one.

#+BEGIN_EXAMPLE
-- step :: Maybe Input -> Challenge -> (Maybe Reward, Challenge)
-- getRewards :: Challenge -> [Input] -> Multiset Reward
-- runChallenge :: Challenge -> [Input] -> (Maybe Reward, Challenge)
-- completes :: Challenge -> [Input] -> Maybe [Input]

-- Law: getRewards
∀ (c :: Challenge).
  getRewards c = fst . runChallenge c

-- Law: completes
∀ (c :: Challenge).
  completes c = (== empty) . snd . runChallenge c

-- NDG: I think this is wrong, on the right there's a `[Input] -> Bool`, on the left a `[Input] -> Maybe [Input]`
#+END_EXAMPLE

* Simmetry
We have a ~both~ constructor, so why not having an ~either~ constructor?

#+BEGIN_SRC haskell :eval never
either :: Challenge -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: "either:associativity"
∀ (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  either (either c1 c2) c3 = either c1 (either c2 c3)

-- Law: "either:commutativity"
∀ (c1 :: Challenge) (c2 :: Challenge).
  either c1 c2 = either c2 c1

-- Law: "either/andThen/reward"
∀ (r :: Reward) (c1 :: Challenge) (c2 :: Challenge).
  either (andThen (reward r) c1) c2 =
    andThen (reward r) (either c1 c2)

-- Law: either/empty
-- ...🤮 why? It would have been better to have `empty` as the identity element?
∀ (c :: Challenge).
  not (isReward c) =>
    either empty c = empty

-- Law: step/either
∀ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step i (either c1 c2) =
    either <$> step i c1 <*> step i c2

-- What we are saing here is that the only terminal challenge is `empty`,
-- and `either` will keep "running" until one of the challenges is `empty`.

-- `either <$> step i c1 <*> step i c2` means that `either` will run the `step`
-- function on input `i` on `c1` and `c2` both, both branch will result in a
-- challenge respectively `c1'` and `c2'`, at the end we will create another
-- `either` challenge with `c1'` and `c2'`, that is until one of the resulting
-- challenge will be `empty`
#+END_EXAMPLE

*Exercise:* Does ~either~ form a monoid? If so, what is its identity element?

Yes by having a challenge that will never complete (ie reduce to ~empty~) such
as ~gate never empty~

*Exercise:* Reduce ~either (reward r1) empty~ to its simmplest form

#+BEGIN_EXAMPLE
either (reward r1) empty   -- return first not empty
reward r1

either (reward r1) empty   -- commutativity
either empty (reward r1)   -- either/empty
reward r1
#+END_EXAMPLE

With short circuit we can create challenges with a time limit

#+BEGIN_SRC haskell :eval never
data Time

time :: Time -> Input
afterTime :: Time -> InputFilter
#+END_SRC

As an example the following is a challenge that can be completed only in the
first hour

#+BEGIN_EXAMPLE
either (gate (afterTime oneHour) empty)
       (pointOfInterest ...)

-- That is because you can "escape" from the `either` only when one of the
-- challenges will be reduced to `empty`, so "either"

-- One of the input will pass the gate -> `empty` without reward -> timeout go home with nothing

-- One of the input will complete (ie terminate with `empty`) the second challenge
-- which presumably has an associated reward
#+END_EXAMPLE

*Exercise:* Encapsulate this timeout behavior in a new timeout constructor. Be
sure to give it a type and suﬀicient laws to entirely specify its behavior.

#+BEGIN_SRC haskell
timeout :: Time -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: timeout
∀ (t :: Time) (c :: Challenge).
  timeout t c = either (gate (afterTime t) empty) c

-- I think there's nothing else to say because what's right of the equation
-- is well specified
#+END_EXAMPLE

Identity element for ~either~

#+BEGIN_SRC haskell
bottom :: Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: bottom
∀ (c :: Challenge).
  bottom = gate never c
#+END_EXAMPLE

* Clues

#+BEGIN_SRC haskell :eval never
-- Until now we have a constructor of a Challenge given a Clue and another Challenge
-- aka a way to attach a Clue to a Challenge
clue :: Clue -> Challenge -> Challenge

-- Constructor of a clue
hint :: String -> Clue

-- Clue can be nested? Why not
-- With this we have a semigroup given the associative law below, and a monoid with the identity element below
sub :: Clue -> Clue -> Clue

-- An observation to "unroll" a clue
toList :: Clue -> [String]

-- The identity element
noClue :: Clue
#+END_SRC

NDG: is it right to say that an "observation" is a function from our algebra to
some common data structure?

#+BEGIN_EXAMPLE
-- Law: sub:associative
∀ (k1 :: Clue) (k2 :: Clue) (k3 :: Clue).
  sub k1 (sub k2 k3) = sub (sub k1 k2) k3

-- Law: toList/hint
∀ (s :: String).
  toList (hit s) = [s]

-- Law: toList/sub
∀ (k1 :: Clue) (k2 :: Clue).
  toList (sub k1 k2) = toList k1 <> toList k2

-- Law: sub/mempty
∀ (k :: Clue).
  sub k noClue = k = sub noClue k

-- Law: clue/noClue
∀ (c :: Challenge)
  clue noClue c = c
#+END_EXAMPLE

#+BEGIN_QUOTE
Laws are most elegant when they preserve meaningful structure
#+END_QUOTE

#+BEGIN_EXAMPLE
-- Law: clue/sub
∀ (k1 :: Clue) (k2 :: Clue) (c :: Challenge).
  clue (sub k1 k2) c = clue k1 (clue k2 c)
#+END_EXAMPLE

SKIPPED: clue/noClue and clue/sub form a monoid homomorphism over endomorphism,
may come back later, maybe not 🤷

Once a player has seen a Clue, then it should last over the challenge (inform
when the challenge behind the clue is completed or no longer available)

#+BEGIN_SRC haskell
-- Clue can be in four states, with the "undiscovered" as an implici state for obvious reasons
data ClueState

seen :: ClueState
completed :: ClueState
failed :: ClueState

-- An observation to collect clues and their states
-- MonoidalMap a Map which uses the instance of Semigroup for the values of conflicting keys
getClues :: Challenge
         -> [Input]
         -> MonoidalMap Clue ClueState

-- The monoid operation for ClueState will keep the makimum of the two ClueState under
-- the following ordering

-- seen < failed < completed

-- The ordering will give us a monoid but also a semilattice (a partially
-- ordered set with an upper and lower bound)
#+END_SRC

To give ~getClues~ semantics using our unified observation ~step~ we need to
change the ~step~ observation because right now it says nothing about clues

#+BEGIN_SRC haskell
-- Before
step :: Maybe Input -> Challenge -> (Multiset Reward, Challenge)

-- After
step :: Clue -- Need to take a clue as the current "clue context" of "where we are"
     -> Maybe Input
     -> Challenge
     -> ( ( Multiset Reward
          , MonoidalMap Clue ClueState
          )
        , Challenge
        )
#+END_SRC

We need to update the laws to pass the clue context, the following is an example

#+BEGIN_EXAMPLE
-- Law: step/both
-- Same context gets propagated to both challenges
∀ (k :: Clue) (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step k i (both c1 c2) = both <$> step k i c1 <*> step k i c2
#+END_EXAMPLE

Now the semantic

#+BEGIN_EXAMPLE
-- Law: step/clue/empty
-- Easy case where the challenge is completed
∀ (kx :: Clue) (i :: Maybe Input) (k :: Clue).
  step kx i (clue k empty) =
    tellClue (singleton (sub kx k) completed) *> empty

-- `tellClue` I think is for communicating with the user
-- `singleton` ??? takes a Clue and a ClueState
-- `completed` is the constructor for the `ClueState`
-- `empty` I think is to create an empty result for `step`

-- Law: step/clue/non-empty
∀ (kx :: Clue) (i :: Maybe Input) (k :: Clue) (c :: Challenge).
  not (isEmpty c) =>
    step kx i (clue k c) =
      tellClue (singleton (sub kx k) seen) *>
        clue <$> pure k <*> step (sub kx k) i c

-- We add the clue `k` to the context
-- We "consume" the input `i` over the Challenge `c`
-- The resulting challenge still has the clue `k`
#+END_EXAMPLE

We still need to report the failed clues in the pruned branches

#+BEGIN_SRC haskell
findClues :: Clue
          -> Challenge
          -> MonoidalMap Clue ClueState
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: step/either
∀ (kx :: Clue) (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge) (c2' :: Challenge) (z1 :: _) (z2 :: _).
  step kx i c1 == (z1, empty) &&
  step kx i c2 == (z2, c2') =>
    step kx i (either c1 c2) =
      seenToFailed (findClues kx c2') *> step kx i c2 *> step kx i c1

-- Law: step/either non-empty
∀ (kx :: Clue) (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge) (c1' :: Challenge) (c2' :: Challenge) (z1 :: _) (z2 :: _).
  step kx i c1 == (z1, c1') &&
  step kx i c2 == (z2, c2') &&
  not (isEmpty c1') && not (isEmpty c2') =>
    step kx i (either c1 c2) =
      either <$> step kx i c1 <*> step kx i c2
#+END_EXAMPLE

* Generalization

The algebra is complete, time to review the unnecessary constraint, start with
the types that we have but we don't use in any law: ~Photo~, ~Point~,
~Distance~, ~Altitude~, ~Time~. The only place they appear is in ~Input~ and
~InputFilter~, but the ~Challenge~ machinery only cares about the ~matches~
observation on ~Input~.

This makes our ~Input~ an excellent candidate to be replaced with a type
variable.

We need to parametrize ~Challenge~ and ~InputFilter~

#+BEGIN_SRC haskell
data Challenge i
data InputFilter i

matches :: InputFilter i -> i -> Bool
gate :: InputFilter i -> Challenge i -> Challenge i
#+END_SRC

Separate the reusable "boolean-like" aspects of the input filter machinery (like
~andF :: InputFilter -> InputFilter -> InputFilter~) and the input specific
aspect (like ~photoWithin :: Point -> Distance -> InputFilter~)

#+BEGIN_SRC haskell
-- `f` is the new type parameter corresponding to the input-specifi piece
class FilterFor f i | f -> i where
  filterMatches :: f -> i -> Bool

-- NOTE: the `| f -> i` part of the type class is known as "Functional
-- Dependency", it means that `i` can be determined from `f`, in other words `i`
-- depends on `f`, as a result `i` can appear only as a result type where `f` is
-- the input type. See https://wiki.haskell.org/index.php?title=Functional_dependencies

-- Since `f` and `i` are tightly coupled, to improve usability we can relate `i`
-- to `f` more directly

class HasFilter i where
  -- NOTE: this feature is called "Associated Types" and it's an application
  -- (syntactic sugar) of a more general feature ie "Open Data Families"
  --
  -- Meaning: for every type `i` there is a corresponding type called
  -- `CustomFilter i` which models the custom filter on `i`
  data CustomFilter i
  filterMatches :: CustomFilter i -> i -> Bool

-- To complete the process we need to lift a `CustomFilter i` to `InputFilter i`
-- so that all the machinery on `InputFilter i` will work on `CustomFilter i`

custom :: HasFilter i => CustomFilter i -> InputFilter i
#+END_SRC

Can we generalize further? What about ~Reward~? It's heavily involved in the
algebra and in the observations, but its content is never inspected. We can
replace the type ~Reward~ in ~reward :: Reward~ with any type ~r~

#+BEGIN_SRC haskell
data Challenge i r

reward :: r -> Challenge i r

step :: (HasFilter i, Monoid r, Commutative r)
     => Clue
     -> Maybe (Input i)
     -> Challenge i r
     -> ( ( r
          , MonoidalMap Clue ClueState
          )
        , Challenge i r
        )
#+END_SRC

Since ~r~ must have an instance of ~Monoid~ it make sense to add some monoid
homomorphism

#+BEGIN_EXAMPLE
-- Law: reward/mempty
reward mempty = empty

-- Law: reward/mappend
reward (r1 <> r2) = andThen (reward r1) (reward r2)

-- Given the definition of "Monoid Homomorphism" from https://proofwiki.org/wiki/Definition:Monoid_Homomorphism
-- Let (S,∘) and (T,∗) be monoids.
-- Let ϕ:S→T be a mapping such that
--   ∀a,b∈S: ϕ(a∘b)=ϕ(a)∗ϕ(b)
--   ϕ(eS)=eT

-- reward (r1 <> r2) -- ϕ(a∘b)
-- andThen (reward r1) (reward r2) -- ϕ(a)∗ϕ(b)
-- They must be equal, we can use the `getRewards` observation
-- ∀ (i :: Input).
--   getRewards i (reward (r1 <> r2)) = [r1, r2]
--   getRewards i (andThen (reward r1) (reward r2)) = getRewards i (reward r1) <> getRewards i (reward r2)
--                                                  = [r1] <> [r2]
--                                                  = [r1, r2]
--
--   getRewards i (reward mempty) = []
--   getRewards i empty = []
#+END_EXAMPLE

Now ~Clue~ is the only concrete things around, but it isomorphic to a list, therefore

#+BEGIN_SRC haskell
data Challenge i k r

clue :: [k] -> Challenge i k r -> Challenge i k r

step :: (HasFilter f, Monoid r, Commutative r, Ord k)
     => [k]
     -> Maybe i
     -> Challenge i k r
     -> ( ( r
          , MonoidalMap [k] ClueState
          )
        , Challenge i k r
        )
#+END_SRC

Nothing remain that is concrete, the ~Challenge~ abstraction is entirely reusable.

#+BEGIN_QUOTE
Firm contracts are our only defense against entropy, and the abstraction
boundaries enforced by parametricity is as strong as they come.
#+END_QUOTE
