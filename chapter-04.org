#+TITLE: Scavenger Hunt

#+STARTUP: inlineimages
#+PROPERTY: header-args:haskell :results replace output
#+PROPERTY: header-args:haskell+ :noweb yes
#+PROPERTY: header-args:haskell+ :wrap EXAMPLE

* A new algebra

We are going to design another algebra, a more "real-world" case study: a
backend service for a "scavenger hunt" platform.

Our service will let players to:

- Run around the city
- Following clues
- Solving puzzles
- Exploring new places
- Doing challenges

Mechanics of the MVP:

- Collect periodic location data of the players
- Players can send geotagged photos
- Locations and geotagged photos will be used to "prove" the progression of the
  player
- For every challege the player completes a "reward" will be given: can be a
  point on the leaderboard or something else
- After a challege is completed, the player is free to tackle another challenge
- Challeges must be defined in a way so that everyone in the company can
  contribute to create them

*Exercise*: Attempt a quick design of this system before continuing. Sketch the
core data types and functions necessary for a scavenger hunt system like
described above. How would you encode a challenge like â€œtake a selfie at the
library, and receive one point afterward.â€

#+BEGIN_SRC haskell :eval never
data Player

data Challege = Challenge(Action, Rewad)

data Action = SelfieAt(Place) -- | ... other actions

data Place = Place(Coordinates)

data Position = Position(Player, Place)

data Reward = Earn(Points) -- | ... other rewards

data Points = Point(Int)

placeKnownAs :: String -> Place
placeKnownAs = undefined

reportPosition :: Player -> Coordinates -> Position
reportPosition = undefined

reportAction :: Challenge -> Player -> Action -> Maybe Reward
reportAction = undefined

challenge = Challenge(SelfieAt(placeKnownAs("library")), Earn(Point(1)))
#+END_SRC

*Exercise*: Try to represent a challenge that requires players to go to the
beach and to the library â€” but in either order â€” and then receive a reward. Can
your initial design represent this problem? If not, modify the core data types
to support this functionality.

#+BEGIN_SRC haskell
data Action = SelfieAt(Place) | Both(Action, Action)

challenge = Challenge(
  Both(
      SelfieAt(placeKnownAs("library")),
      SelfieAt(placeKnownAs("beach"))),
  Earn(Point(1))
)
#+END_SRC

#+BEGIN_QUOTE
A great place to begin any algebra is by determining some of its observations,
that is, the answer to â€œwhat is the purpose of this thing weâ€™re building?â€
#+END_QUOTE

#+BEGIN_SRC haskell :eval never
data Challenge
data Input
data Reward

getRewards :: Challenge -> [Input] -> [Reward]
#+END_SRC

Algebra-Driven Design forces us to be /denotational/ therefore we cannot use
mutation of variables therefore we must receive the whole player history to
determine the rewards.

#+BEGIN_SRC haskell :eval never
data Clue
data Point
data Distance

pointOfInterest :: Clue
                -> Point
                -> Distance
                -> Reward
                -> Challege

photo :: Point -> Photo -> Input
within :: Point -> Point -> Distance -> Bool
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: point of interest
-- if the challenge is a pointOfInterest, and the user sends us a photo
-- taken in the proximity circle, then they should receive the associated reward.

âˆ€ (c :: Clue) (poi :: Point) (d :: Distance) (r :: Reward) (p :: Point) (pic :: Photo) (is: [Input]).
  within poi p d =>
    getRewards (pointOfInterest c poi d r)
               (photo p pic : is)
               = [r]
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Law: outside point of interest
-- states that the getRewards of a pointOfInterest ignores any photo inputs that
-- are not within the location tolerance.

âˆ€ (c :: Clue) (poi :: Point) (d :: Distance) (r :: Reward) (p :: Point) (pic :: Photo) (is: [Input]).
  not (within poi p d) =>
    getRewards (pointOfInterest c poi d r)
               (photo p pic : is)
               =
    getRewards (pointOfInterest c poi d r)
               is
#+END_EXAMPLE

#+BEGIN_EXAMPLE
-- Law: unmatching point of interest
-- ignore any input which is not a photo

-- given the trivial observation `isPhoto :: Input -> Bool`

âˆ€ (c :: Clue) (poi :: Point) (d :: Distance) (r :: Reward) (i :: Input) (is: [Input]).
  not (isPhoto i) =>
    getRewards (pointOfInterest c poi d r)
               (i : is)
               =
    getRewards (pointOfInterest c poi d r)
               is
#+END_EXAMPLE

This time the laws seems more convoluted, is it because the domain is more
complex or because we got the wrong algebra?

#+BEGIN_QUOTE
Involved equations are a classic symptom of designing the wrong algebra.
#+END_QUOTE

Note that the ~pointOfInterest~ constructor takes 4 parameters and does 3
orthogonal things:
- Informing the user (the ~Clue~)
- Describing an area (the ~Point~ and ~Distance~)
- Giving a ~Reward~

Looking at the laws:
- All three laws don't care about the ~Clue~
- Two of them don't care about the ~Reward~ (NDG: mmm, but they always compare
  the result of ~getRewards~ which is a list of ~Reward~ ðŸ¤”)

Conclusion: ~pointOfInterest~ is not about ~Clue~ and ~Reward~

#+BEGIN_SRC haskell :eval never
clue :: Clue -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: getRewards/clue
-- clues do not affect rewards

âˆ€ (cl :: Clue) (ch :: Challenge).
  getRewards (clue cl ch) = getRewards ch

-- NDG: are we missing the inputs? Should have been
âˆ€ (cl :: Clue) (ch :: Challenge) (is :: [Input]).
  getRewards (clue cl ch) is = getRewards ch is

-- NDG: it's basically the same thing considering an eta reduction on `is`,
-- aka: the first law is comparing two functions both awaiting `is`, they
-- will be equal `f1 = f2 iff âˆ€ (is : [Input]). f1 is = f2 is`
#+END_EXAMPLE

By intuition we make a ~reward~ constructor a terminal able to create a
~Challenge~ from nothing.

#+BEGIN_SRC haskell :eval never
reward :: Reward -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law :: getRewards/reward
-- a `reward` challenge doesn't have any requirements, for every input we give the reward

âˆ€ (r :: Reward) (is :: [Input]).
  getReward (reward r) is = [r]
#+END_EXAMPLE

*Exercise*: Reduce ~getRewards (clue c (reward r)) i~ to its simplest form via
algebraic manipulation.

#+BEGIN_EXAMPLE
getRewards (clue c (reward r)) i    -- using: getRewards (clue cl ch) = getRewards ch
getRewards (reward r) i             -- using: getReward (reward r) i = [r]
[r]
#+END_EXAMPLE

We can pull the remaining two parameters (~Point~ and ~Distance~) in their own constructor

#+BEGIN_SRC haskell :eval never
photoWithin :: Point
            -> Distance
            -> Challenge
            -> Challenge
#+END_SRC

The idea is that ~photoWithin~ will wait until a photo has been taken within the
tollerance and before switching to its ~reward~ challege (which will give
immediately back the reward)

#+BEGIN_EXAMPLE
-- Law: getReward/photoWithin

âˆ€ (poi :: Point) (p :: Point) (pic :: Photo) (d :: Distance) (c :: Challege) (is :: [Input]).
  within poi p d =>
    getRewards (photoWithin poi d c) (photo p pic : is) = getRewards c is

-- NDC: I'm not convinced, this means that you need to build build "carefully" the challenge, you can miss the reward

-- We still need to express the laws describing the behaviour of not getting a reward if
-- the selfie is not in range and if the input is not a selfie

-- Law: getReward/photoWithin outside range
âˆ€ (poi :: Point) (p :: Point) (pic :: Photo) (d :: Distance) (c :: Challege) (is :: [Input]).
  not (within poi p d) =>
    getRewards (photoWithin poi d c) (photo p pic : is) = getRewards (photoWithin poi d c) is

-- Law: getReward/photoWithin unmatching photoWithin
âˆ€ (poi :: Point) (d :: Distance) (c :: Challege) (i :: Input) (is :: [Input]).
  not (isPhoto) =>
    getRewards (photoWithin poi d c) (i : is) = getRewards (photoWithin poi d c) is

-- Law: pointOfInterest
-- pointOfInterest now can be espressed by composition of simpler constructors
âˆ€ (c :: Clue) (p :: Point) (d :: Distance) (r :: Reward).
  pointOfInterest c p d r = clue c (photoWithin p d (reward r))
#+END_EXAMPLE

We need to be able to track if the photo was taken at a certain altitude (ex.
for a building rooftop)

#+BEGIN_SRC haskell :eval never
data Altitude

photoAbove :: Altitude
           -> Challenge
           -> Challenge

-- to replace `within` predicate
aboveAltitude :: Point -> Altitude -> Bool
#+END_SRC

NOTE: in our laws we used directly ~within~ so the laws are not generic on the
predicate or on the kind of challenge

* Input Filters

There are similarities between ~photoWithin~ and ~photoAbove~, they both scan
through an ~Input~ list until they are satisfied. Can we parametrize this
behaviour?

#+BEGIN_SRC haskell :eval never
data InputFilter

matches :: InputFilter -> Input -> Bool

photoWithin :: Point -> Distance -> InputFilter
photoAbove :: Altitude -> InputFilter
#+END_SRC

*Exercise:* Give semantics in terms of matches for both ~photoWithin~ and
~photoAbove~.

#+BEGIN_EXAMPLE
-- Law: matches/photoWithin
âˆ€ (p1 :: Point) (p2 :: Point) (d :: Distance) (pic :: Photo).
  matches (photoWithin p1 d) (photo p2 pic) = within p1 p2 d

-- Law: matches/photoAbove
âˆ€ (p :: Point) (h :: Altitude) (pic :: Photo).
  matches (photoAbove h) (photo p pic) = aboveAltitude p h
#+END_EXAMPLE

We can then create a constructor for ~Challege~ which will apply the filter.

#+BEGIN_SRC haskell :eval never
gate :: InputFilter -> Challenge -> Challenge
#+END_SRC

With the following semantics

#+BEGIN_EXAMPLE
-- Law: getRewards/gate
âˆ€ (c :: Challenge) (f :: InputFilter) (i :: Input) (is :: [Input]).
  matches f i =>
    getRewards (gate f c) (i : is) = getRewards c is

-- Law: getRewards/gate unmatched
âˆ€ (c :: Challenge) (f :: InputFilter) (i :: Input) (is :: [Input]).
  not (matches f i) =>
    getRewards (gate f c) (i : is) = getRewards (gate f c) is

-- Law: getRewards/gate empty
âˆ€ (c :: Challenge) (f :: InputFilter).
  getRewards (gate f c) [] = []
#+END_EXAMPLE

Finally we can now express ~pointOfInterest~ in terms of gate

#+BEGIN_EXAMPLE
-- Law: pointOfInterest
âˆ€ (c :: Clue) (p :: Point) (d :: Distance) (r :: Reward).
  pointOfInterest c p d r = clue c (gate (photoWithin p d) (reward r))
#+END_EXAMPLE

Can we combine more ~InputFilter~?

#+BEGIN_SRC haskell
always :: InputFilter
never :: InputFilter

andF :: InputFilter -> InputFilter -> InputFilter
orF :: InputFilter -> InputFilter -> InputFilter
notF :: InputFilter -> InputFilter
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: matches/always
âˆ€ (i :: Input).
  matches always i = True

-- Law: matches/never
âˆ€ (i :: Input).
  matches never i = False

-- Law: matches/andF
âˆ€ (i :: Input) (f1 :: InputFilter) (f2 :: InputFilter).
  matches (andF f1 ff2) i = matches f1 i && matches f2 i

-- Law: matches/orF
âˆ€ (i :: Input) (f1 :: InputFilter) (f2 :: InputFilter).
  matches (andF f1 ff2) i = matches f1 i || matches f2 i

-- Law: matches/notF
âˆ€ (i :: Input) (f :: InputFilter).
  matches (notF f) i = not (matches f i)
#+END_EXAMPLE

* Simultaneous Challenges

*Exercise:* Consider the term ~gate (photoWithin p1 d1) (gate (photoWithin p2
d2) (reward r))~. What is your intuitive understanding of this expression? Do
our stated semantics agree with you? Hint: try evaluating ~getRewards~ of the
above, using two different photo inputs.

#+BEGIN_EXAMPLE
-- The player will get a reward if the input sequence contains first a photo matching the
-- filter `(photoWithin p1 d1)` and the a photo matchin the filter `(photoWithin p2 d2)`

getRewards (gate (photoWithin p1 d1) (gate (photoWithin p2 d2) (reward r))) ((photo p3 pic1) : (photo p4 pic2) : [])
-- if (matches (photoWithin p1 d1) (photo p3 pic1))
getRewards (gate (photoWithin p2 d2) (reward r)) ((photo p4 pic2) : [])
-- if (matches (photoWithin p2 d2) (photo p4 pic2))
getRewards (reward r) []
-- using `getReward (reward r) is = [r]`
[r]
#+END_EXAMPLE

We can create a new ~InputFilter~ to check the passive location data of the player

#+BEGIN_SRC haskell :eval never
logWithin :: Point -> Distance -> InputFilter
#+END_SRC

*Exercise:* Use ~locWithin~ to encode a challenge that requires our player to
walk around the block twice, clockwise, as in figure 4.9. Assume you have p1,
p2, p3 :: Point and d1, d2, d3 :: Distance corresponding to each cornerâ€™s
locations and tolerances.

#+BEGIN_SRC haskell :eval never
aroundTheBlock :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlock [] c = c
aroundTheBlock ((p, d):t) c = gate (logWith p d) (aroundTheBlock t c)

aroundTheBlockTwice :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlockTwice ps c = aroundTheBlock ps (aroundTheBlock ps c)

twice :: (Challenge -> Challenge) -> Challenge -> Challenge
twice build c = build (build c)

aroundTheBlockTwice' :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlockTwice' ps c = twice (aroundTheBlock ps) c

repeatN :: Int -> (Challenge -> Challenge) -> Challenge -> Challenge
repeatN 0 _ c = c
repeatN n build c = build $ repeatN (n - 1) build c

aroundTheBlockTwice'' :: [(Point, Distance)] -> Challenge -> Challenge
aroundTheBlockTwice'' ps c = repeatN 2 (aroundTheBlock ps) c
#+END_SRC

Can we encode a challenge in which players can visit several points of interest
in ~any~ order?

We need a new constructor

#+BEGIN_SRC haskell :eval never
both :: Challenge -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: both/commutative
âˆ€ (c1 :: Challenge) (c2 :: Challenge).
  both c1 c2 = both c2 c1

-- Law: both/associative
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  both (both c1 c2) c3 = both c1 (both c2 c3)

-- Law: both/idempotent
âˆ€ (c :: Challenge).
  both c c = c

-- Law
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  getRewards (both c1 c2) is = (getRewards c1 is) ++ (getRewards c2 is)
#+END_EXAMPLE

*Exercise:* Prove that ~both (both c1 c2) (both c3 c4) = both c1 (both c2 (both
c3 c4))~. How might an implementation use this fact?

#+BEGIN_EXAMPLE
both (both c1 c2) (both c3 c4) = both c1 (both c2 (both c3 c4))

both (both c1 c2) (both c3 c4) -- from associativity
both c1 (both c2 (both c3 c4))

-- Can be used to balance the tree, to reduce the depth of the tree, to improve performance
#+END_EXAMPLE

With ~both~ the player gets both the rewards of the composing challenges, but
what about we want to give the reward only when all the challenges are complete?

We miss the capability to create a ~Challenge~ that has no reward at the end

#+BEGIN_SRC haskell :eval never
empty :: Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: getRewards/empty
âˆ€ (is :: [Input]).
  getRewards empty is = []

âˆ€ (c :: Challenge).
  both empty c = c = both c empty
#+END_EXAMPLE

* Challenge Completing

Right now we don't have a way to wait for a challenge completion to go to the
next challenge, for example in case of ~both c1 c2~ the player will get both the
rewards for ~c1~ and ~c2~, we cannot say "if the player completes both
challenges then this is the reward"

We need a new combinator for that, a combinator capable of /sequencing/
challenges

#+BEGIN_SRC haskell :eval never
andThen :: Challenge -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: andThen/gate
âˆ€ (f :: InputFilter) (c1 :: Challenge) (c2 :: Challenge).
  andThen (gate f c1) c2 = gate f (andThen c1 c2)

-- Law: andThen:associative
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  andThen (andThen c1 c2) c3 = andThen c1 (andThen c2 c3)

-- Law: andThen:identity
âˆ€ (c :: Challenge).
  andThen c empty = andThen empty c = c
#+END_EXAMPLE

We lack a strong definition of challenge /completion/

#+BEGIN_QUOTE
Semantics must always be relative to an observation
#+END_QUOTE

Our only observation for challenges so far is ~getRewards~ which is not suited
to define challenges completion, we need another observation.

Let's try using the following (spoiler: it's not compositional enough because it
doesn't tell us how much input is needed for a challenge to complete)

#+BEGIN_SRC haskell :eval never
completes :: Challenge -> [Input] -> Bool
#+END_SRC

*Exercise:* Give semantics for ~andThen~ in terms of ~completes~ as defined
 above. Show that this semantic necessarily contradict "andThen/gate"

#+BEGIN_EXAMPLE
-- Law: completes/andThen
âˆ€ (c1 :: Challenge) (c2 :: Challege) (is1 :: [Input]) (is2 :: [Input]).
  completes c1 is1 && completes c2 is2 =>
    completes (andThen c1 c2) (is1 ++ is2)

-- Law: completes/gate
âˆ€ (f :: InputFilter) (c :: Challenge) (i: Input) (is: [Input]).
  matches f i =>
    completes (gate f c) (i :: is) = completes c is

âˆ€ (f :: InputFilter) (c :: Challenge) (i: Input) (is: [Input]).
  not (matches f i) =>
    completes (gate f c) (i :: is) = false

-- Law: completes/end
âˆ€ (c :: Challenge).
  completes c [] = false

-- Law: completes/reward
âˆ€ (is :: [Input]) (reward R).
  completes (reward R) is = true

-- Law: completes/empty
âˆ€ (is :: [Input]).
  completes empty is = true

--
--
-- Given the following law
âˆ€ (f :: InputFilter) (c1 :: Challenge) (c2 :: Challenge).
  andThen (gate f c1) c2 = gate f (andThen c1 c2)

âˆ€ (c1 :: Challenge) (c2 :: Challege) (i :: Input) (is1 :: [Input]) (is2 :: [Input]).
  completes (gate f c1) (i : is1) && completes c2 is2 =>
    completes (andThen (gate f c1) c2) ((i : is1) ++ is2)

-- the following expression
completes (andThen (gate f c1) c2) ((i : is1) ++ is2)
-- should be equal to
completes (gate f (andThen c1 c2)) ((i : is1) ++ is2)

-- but the second form will consume all the input to check if `gate` is satisfied
#+END_EXAMPLE

More composable version of ~completes~ will preserve the information on the
amount of input necessary to complete a challege and leave the rest

#+BEGIN_SRC haskell
completes :: Challenge -> [Input] -> Maybe [Input]
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: completes/empty
-- An empty challenge is always completed
âˆ€ (is :: [Input]).
  completes empty is = Just is

-- Law: completes/reward
-- A reward challenge is always completed
âˆ€ (r :: Reward) (is :: [Input]).
  completes (reward r) is = Just is

-- Law: completes/both
-- where `shorterOf :: [a] -> [a] -> [a]` will return the shorter not consumed input
âˆ€ (c1 :: Challege) (c2 :: Challenge) (is :: [Input]).
  completes (both c1 c2) is = shorterOf <$> completes c1 is <*> completes c2 is
#+END_EXAMPLE

*Exercise:* Give a law for the behaviour of ~shorterOf~

#+BEGIN_EXAMPLE
-- Law: shorter:behaviour
âˆ€ (as :: [a]) (a :: a).
  shorterOf (a : as) as = as

-- Law: shorter:base
âˆ€ (as :: [a]).
  shorterOf as [] = []

-- Law: shorter:commutative
âˆ€ (as1 :: [a]) (as2 :: [a]).
  shorterOf as1 as2 = shorterOf as2 as1

-- Law: shorter:associative
âˆ€ (as1 :: [a]) (as2 :: [a]) (as3 :: [a]).
  shorterOf as1 (shorterOf as2 as3) = shorterOf (shorterOf as1 as2) as3

-- Law: shorter:identity
âˆ€ (as :: [a]).
  shorterOf as as = as
#+END_EXAMPLE

*Exercise:* Does shorterOf form a monoid? If so, give it. If not, show which
laws it doesnâ€™t satisfy.

No, the /identity element/ doesn't exists (should have been the infinitely long
list), but it's associative, therefore it's a semigroup

Going further with the laws regarding the ~completes~ observation

#+BEGIN_EXAMPLE
-- Law: completes/clue
âˆ€ (k :: Clue) (c :: Challege) (is :: [Input]).
  completes (clue k c) is = completes c is

-- Law: completes/gate
âˆ€ (f :: InputFilter) (c :: Challege) (i :: Input) (is :: [Input]).
  matches f i =>
    completes (gate f c) (i : is) = completes c is

-- Law: completes/gate unmatched
âˆ€ (f :: InputFilter) (c :: Challege) (i :: Input) (is :: [Input]).
  not (matches f i) =>
    completes (gate f c) (i : is) = completes (gate f c) is

-- Law: completes/gate empty
âˆ€ (f :: InputFilter) (c :: Challege).
  completes (gate f c) [] = Nothing
#+END_EXAMPLE

Now we can properly specify the semantics of ~andThen~ under ~completes~ because
we can use the rest of the input of the first challenge to run the second
challenge

#+BEGIN_EXAMPLE
-- Law: completes/andThen
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  completes c1 is >>= completes c2

-- (>>=) :: Monad m => m a -> (a -> m b) -> m b
-- Maybe [Input] >>= ([Input] -> Maybe [Input])

-- flatMap[M[_], A, B](ma : M[A])(f: A => M[B]): M[B]
-- flatMap(ma : Option[Input[]])(f: Input[] => Option[Input[]]): Option[Input[]]
#+END_EXAMPLE

#+BEGIN_QUOTE
Using ~>>=~ is highly appropriate, monadic binds are used to encode strict
sequencing of evaluation in lazy languages. Transforming from constructors to a
well-understood operation is a recurring theme in Algebra-Driven Design, and
this is the proof that our algebra behaves liek we say it should.
#+END_QUOTE

Last thing is to give semantics of ~andThen~ under ~getRewards~

#+BEGIN_EXAMPLE
-- Law: getRewards/andThen
-- This should be good for both cases
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  getRewards (andThen c1 c2) is =
    (getRewards c1 is) <> (getRewards c2 <$> completes c1 is)

-- More explicit
-- Law: getRewards/andThen
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]) (is' :: [Input]).
  completes c1 is == Just is' =>
    getRewards (andThen c1 c2) is =
      getRewards c1 is <> getRewards c2 is'

-- Law: getRewards/andThen incomplete
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (is :: [Input]).
  completes c1 is == Nothing =>
    getRewards (andThen c1 c2) is =
      getRewards c1 is
      -- That is because c1 never completes, therefore the
      -- remaining input will be empty, therefore the c2
      -- challenge will result in empy rewards, therefore
      -- can be elimnated
#+END_EXAMPLE

* Simplification

Give distributive laws when possible

#+BEGIN_EXAMPLE
-- Law: both/andThen/reward
âˆ€ (r :: Reward) (c1 :: Challenge) (c2 :: Challenge).
  both (andThen (reward r) c1) c2 =
    andThen (reward r) (both c1 c2)
#+END_EXAMPLE

Our algebra is *inconsistent!!!*, it shows a non-confluence, aka a term can be
reduced in two different lawful ways to two diffent terms.

#+BEGIN_QUOTE
In computer science and mathematics, /confluence/ is a property of rewriting
systems, describing which terms in such a system can be rewritten in more than
one way, to yield the /same result/.
#+END_QUOTE

#+BEGIN_EXAMPLE
both (reward r1) (reward r2)                   -- using: andThen c empty = andThen empty c = c
both (andThen (reward r1) empty) (reward r2)   -- using: both (andThen (reward r) c1) c2 = andThen (reward r) (both c1 c2)
andThen (reward r1) (both empty (reward r2))   -- using: both (empty c) = c
andThen (reward r1) (reward r2)

both (reward r1) (reward r2)                   -- using: both c1 c2 = both c2 c1
both (reward r2) (reward r1)                   -- using: andThen c empty = andThen empty c = c
both (andThen (reward r2) empty) (reward r1)   -- using: both (andThen (reward r) c1) c2 = andThen (reward r) (both c1 c2)
andThen (reward r2) (both empty (reward r1))   -- using: both (empty c) = c
andThen (reward r2) (reward r1)

-- Therefore
andThen (reward r2) (reward r1) == andThen (reward r1) (reward r2)

-- Is this true? For a human yes ðŸ˜ƒ for a formal system no!
-- That is because when observed through `gerRewards` we get that

getRewards (andThen (reward r2) (reward r1)) = [r1, r2]
getRewards (andThen (reward r1) (reward r2)) = [r2, r1]

-- But

[r1, r2] !== [r2, r1]
#+END_EXAMPLE

The problem lies in the relationship between ~both:commutative~ and
~both:idempotent~ and the rewarding system represented as a list of rewards, and
a list is neither commutaive nor idempotent

How to fix it?
- Abandon the ~both:commutative~ and ~both:idempotent~ laws
- Change the result type of ~getRewards~
- Try to force commutativity and idempotence in lists with ad-hoc laws

NDG: I don't understand the following quote

#+BEGIN_QUOTE
Invariants are a feature of the implementation, not of the design.
#+END_QUOTE

Changing the result type of ~getRewards~ to be both commutative and idempotent
seems to be the way, we can use a [[https://en.wikipedia.org/wiki/Multiset][Multiset]]

NDG: So the algebra was inconsistent, but we fixed it by changing an observation
ðŸ¤”

#+BEGIN_SRC haskell
getRewards :: Challenge -> [Input] -> Multiset Reward
#+END_SRC

* A Unified Observation
Looking at what we have right now:
- Feels like it's still complicated to evaluate challenges
- We can operate algebraic reductions without the need of inputs
- Looking at our current observations (~getRewards~ and ~completes~) all of them
  only requires the first input in the sequence of inputs, every time we need to
  duplicate the "traversal" of the inputs, aka is not required for inputs to be
  a list

We can propose another observation meant to replace both the previous
observations. NOTE: it works only considering ~empty~ as the only "complete"
challenge (aka when to stop the "steps")

#+BEGIN_SRC haskell :eval never
step :: Maybe Input -> Challenge -> (Maybe Reward, Challenge)
#+END_SRC

NDG: probably we can use ~(Maybe Reward, Maybe Challenge)~ instead of having an
~empty~ challenge, but I know why he did that, because otherwise the laws below
would be more convoluted (~(a, Maybe)~ is an ~Applicative Applicate~)

#+BEGIN_EXAMPLE
-- Law: step/both
âˆ€ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step i (both c1 c2) = both <$> (step i c1) <*> (step i c2)

-- How it works?
-- (step i c1) :: (Maybe Reward, Challenge)
-- (a,) has an instance of `Applicative` only if `Monoid a`
-- both :: Challenge -> Challenge -> Challenge
-- both <$> (a, Challenge) :: (a, Challenge -> Challenge)
-- both <$> (a, Challenge) <*> (a, Challenge) :: (a, Challenge)
-- where the `a` in the first element of the tuple gets "merged" using its monoid instance

-- in the end the result will be `(rc1 <> rc2, both cc1 cc2)`
-- where `rcN` are the rewards for `(step i cN)`
-- and `ccN` are the challenges for `(step i cN)`

-- Law: step/empty
âˆ€ (i :: Maybe Input).
  step i empty = pure empty -- meaning `(mempty, empty)` where `mempty :: Monoid a => a`

-- Law: step/reward
âˆ€ (i :: Maybe Input) (r :: Reward).
  step i (reward r) = (singleton r, empty) -- where `singleton :: a -> Multiset a`

-- Law: step/gate
âˆ€ (i :: Input) (f :: InputFilter) (c :: Challenge).
  matches f i =>
    step (Just i) (gate f c) = step Nothing c

-- NDG: I would have said `= pure c` which is the equivalent given the law below "step/gate nothing"

-- Law: step/gate unmatched
âˆ€ (i :: Input) (f :: InputFilter) (c :: Challenge).
  not (matches f i) =>
    step (Just i) (gate f c) = pure (gate f c)

-- Law: step/gate nothing
âˆ€ (f :: InputFilter) (c :: Challenge).
  step Nothing (gate f c) = pure (gate f c)

-- Law: step/andThen complete
âˆ€ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge) (r :: Reward).
  step i c1 == (r, empty) =>
    step i (andThen c1 c2) = join (r, step Nothing c2)

-- join :: Monad a => Monad (Monad a) = Monad a
-- here join :: (,) (,) a -> (,) a
-- here (r, step Nothing c2) -> (r, (r1, c3)) -> (r <> r1, c3)

-- Why `step Nothing c2` ???
-- first we should note that: `step Nothing c2 = pure c2`
-- then, with this we are not saying that we are running the second
-- challenge without input, but that we are returning the second
-- challenge to whoever is consuming the inputs using `step`

-- The following is the general version

-- Law: step/andThen incomplete
âˆ€ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step i c1 == (_, c1') && not (isEmpty c1') =>
    step i (andThen c1 c2) = andThen <$> step i c1 <*> pure c2
#+END_EXAMPLE

This is how we will "consume" the inputs

#+BEGIN_EXAMPLE
âˆ€ (c :: Challenge).
  runChallenge c = foldM step c . (Nothing :) . fmap Just

-- `fmap Just` turns `[Input]` in `[Maybe Input]`
-- `(Nothing : )` prepends a Nothing to the list of input `Nothing : [Maybe Input]` to be able
-- to run the challenge at least once even when there's no input available
-- At the end we fold the `[Maybe Input]` starting with `c` using `step`

-- foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- We can do that because `Monoid a => Monad ((,) a)` aka there's an instance of `Monad`
-- for two elements tuples where the first element has an instance of `Monoid`, and
-- `Reward` has an instance of `Monoid`
#+END_EXAMPLE

If we worry that we lost something with the unified observation, we can try to
implement the original observations using the unified one.

#+BEGIN_EXAMPLE
-- step :: Maybe Input -> Challenge -> (Maybe Reward, Challenge)
-- getRewards :: Challenge -> [Input] -> Multiset Reward
-- runChallenge :: Challenge -> [Input] -> (Maybe Reward, Challenge)
-- completes :: Challenge -> [Input] -> Maybe [Input]

-- Law: getRewards
âˆ€ (c :: Challenge).
  getRewards c = fst . runChallenge c

-- Law: completes
âˆ€ (c :: Challenge).
  completes c = (== empty) . snd . runChallenge c

-- NDG: I think this is wrong, on the right there's a `[Input] -> Bool`, on the left a `[Input] -> Maybe [Input]`
#+END_EXAMPLE

* Simmetry
We have a ~both~ constructor, so why not having an ~either~ constructor?

#+BEGIN_SRC haskell :eval never
either :: Challenge -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: "either:associativity"
âˆ€ (c1 :: Challenge) (c2 :: Challenge) (c3 :: Challenge).
  either (either c1 c2) c3 = either c1 (either c2 c3)

-- Law: "either:commutativity"
âˆ€ (c1 :: Challenge) (c2 :: Challenge).
  either c1 c2 = either c2 c1

-- Law: "either/andThen/reward"
âˆ€ (r :: Reward) (c1 :: Challenge) (c2 :: Challenge).
  either (andThen (reward r) c1) c2 =
    andThen (reward r) (either c1 c2)

-- Law: either/empty
-- ...ðŸ¤® why? It would have been better to have `empty` as the identity element?
âˆ€ (c :: Challenge).
  not (isReward c) =>
    either empty c = empty

-- Law: step/either
âˆ€ (i :: Maybe Input) (c1 :: Challenge) (c2 :: Challenge).
  step i (either c1 c2) =
    either <$> step i c1 <*> step i c2

-- What we are saing here is that the only terminal challenge is `empty`,
-- and `either` will keep "running" until one of the challenges is `empty`.

-- `either <$> step i c1 <*> step i c2` means that `either` will run the `step`
-- function on input `i` on `c1` and `c2` both, both branch will result in a
-- challenge respectively `c1'` and `c2'`, at the end we will create another
-- `either` challenge with `c1'` and `c2'`, that is until one of the resulting
-- challenge will be `empty`
#+END_EXAMPLE

*Exercise:* Does ~either~ form a monoid? If so, what is its identity element?

Yes by having a challenge that will never complete (ie reduce to ~empty~) such
as ~gate never empty~

*Exercise:* Reduce ~either (reward r1) empty~ to its simmplest form

#+BEGIN_EXAMPLE
either (reward r1) empty   -- return first not empty
reward r1

either (reward r1) empty   -- commutativity
either empty (reward r1)   -- either/empty
reward r1
#+END_EXAMPLE

With short circuit we can create challenges with a time limit

#+BEGIN_SRC haskell :eval never
data Time

time :: Time -> Input
afterTime :: Time -> InputFilter
#+END_SRC

As an example the following is a challenge that can be completed only in the
first hour

#+BEGIN_EXAMPLE
either (gate (afterTime oneHour) empty)
       (pointOfInterest ...)

-- That is because you can "escape" from the `either` only when one of the
-- challenges will be reduced to `empty`, so "either"

-- One of the input will pass the gate -> `empty` without reward -> timeout go home with nothing

-- One of the input will complete (ie terminate with `empty`) the second challenge
-- which presumably has an associated reward
#+END_EXAMPLE

*Exercise:* Encapsulate this timeout behavior in a new timeout constructor. Be
sure to give it a type and suï¬€icient laws to entirely specify its behavior.

#+BEGIN_SRC haskell
timeout :: Time -> Challenge -> Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: timeout
âˆ€ (t :: Time) (c :: Challenge).
  timeout t c = either (gate (afterTime t) empty) c

-- I think there's nothing else to say because what's right of the equation
-- is well specified
#+END_EXAMPLE

Identity element for ~either~

#+BEGIN_SRC haskell
bottom :: Challenge
#+END_SRC

#+BEGIN_EXAMPLE
-- Law: bottom
âˆ€ (c :: Challenge).
  bottom = gate never c
#+END_EXAMPLE

* Clues
TODO

* Generalization
TODO
